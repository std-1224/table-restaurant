-- Table Management System Schema for Supabase
-- Run this in your Supabase SQL Editor

-- Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create custom types for enum fields
CREATE TYPE table_status AS ENUM ('free', 'occupied', 'waiting_order', 'producing', 'delivered', 'bill_requested', 'paid');
CREATE TYPE session_status AS ENUM ('active', 'closed');
CREATE TYPE notification_type AS ENUM ('waiter_call', 'bill_request', 'special_request');
CREATE TYPE notification_status AS ENUM ('pending', 'resolved');

-- Create tables table
CREATE TABLE tables (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    venue_id UUID NOT NULL,
    table_number INTEGER NOT NULL,
    capacity INTEGER NOT NULL CHECK (capacity > 0),
    current_guests INTEGER DEFAULT 0 CHECK (current_guests >= 0),
    status table_status DEFAULT 'free',
    assigned_waiter_id UUID,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT check_current_guests_capacity CHECK (current_guests <= capacity),
    CONSTRAINT unique_table_per_venue UNIQUE (venue_id, table_number)
);

-- Create table_sessions table
CREATE TABLE table_sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    table_id UUID NOT NULL REFERENCES tables(id) ON DELETE CASCADE,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    total_spent DECIMAL(10,2) DEFAULT 0.00 CHECK (total_spent >= 0),
    status session_status DEFAULT 'active',
    
    -- Constraints
    CONSTRAINT check_session_times CHECK (end_time IS NULL OR end_time >= start_time),
    CONSTRAINT check_closed_session_end_time CHECK (
        (status = 'closed' AND end_time IS NOT NULL) OR 
        (status = 'active' AND end_time IS NULL)
    )
);

-- Create table_orders table
CREATE TABLE table_orders (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    table_id UUID NOT NULL REFERENCES tables(id) ON DELETE CASCADE,
    order_id UUID NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT unique_table_order UNIQUE (table_id, order_id)
);

-- Create table_notifications table
CREATE TABLE table_notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    table_id UUID NOT NULL REFERENCES tables(id) ON DELETE CASCADE,
    type notification_type NOT NULL,
    status notification_status DEFAULT 'pending',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    resolved_at TIMESTAMPTZ,
    
    -- Constraints
    CONSTRAINT check_resolved_notification CHECK (
        (status = 'resolved' AND resolved_at IS NOT NULL) OR 
        (status = 'pending' AND resolved_at IS NULL)
    )
);

-- Create indexes for better performance
CREATE INDEX idx_tables_venue_id ON tables(venue_id);
CREATE INDEX idx_tables_status ON tables(status);
CREATE INDEX idx_tables_assigned_waiter ON tables(assigned_waiter_id);
CREATE INDEX idx_table_sessions_table_id ON table_sessions(table_id);
CREATE INDEX idx_table_sessions_status ON table_sessions(status);
CREATE INDEX idx_table_orders_table_id ON table_orders(table_id);
CREATE INDEX idx_table_orders_order_id ON table_orders(order_id);
CREATE INDEX idx_table_notifications_table_id ON table_notifications(table_id);
CREATE INDEX idx_table_notifications_status ON table_notifications(status);
CREATE INDEX idx_table_notifications_type ON table_notifications(type);

-- Create trigger function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for tables
CREATE TRIGGER update_tables_updated_at 
    BEFORE UPDATE ON tables 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Create trigger function to auto-resolve notifications when table status changes
CREATE OR REPLACE FUNCTION auto_resolve_notifications()
RETURNS TRIGGER AS $$
BEGIN
    -- Auto-resolve waiter_call notifications when table status changes from occupied
    IF OLD.status = 'occupied' AND NEW.status != 'occupied' THEN
        UPDATE table_notifications 
        SET status = 'resolved', resolved_at = NOW()
        WHERE table_id = NEW.id 
          AND type = 'waiter_call' 
          AND status = 'pending';
    END IF;
    
    -- Auto-resolve bill_request notifications when table is paid
    IF NEW.status = 'paid' THEN
        UPDATE table_notifications 
        SET status = 'resolved', resolved_at = NOW()
        WHERE table_id = NEW.id 
          AND type = 'bill_request' 
          AND status = 'pending';
    END IF;
    
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger for auto-resolving notifications
CREATE TRIGGER auto_resolve_table_notifications
    AFTER UPDATE ON tables
    FOR EACH ROW
    EXECUTE FUNCTION auto_resolve_notifications();

-- Add Row Level Security (RLS) policies if needed
-- Uncomment and modify based on your authentication requirements

-- ALTER TABLE tables ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE table_sessions ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE table_orders ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE table_notifications ENABLE ROW LEVEL SECURITY;

-- Example RLS policies (modify based on your auth setup)
-- CREATE POLICY "Users can view tables in their venue" ON tables
--     FOR SELECT USING (venue_id IN (SELECT id FROM venues WHERE owner_id = auth.uid()));

-- CREATE POLICY "Users can update tables in their venue" ON tables
--     FOR UPDATE USING (venue_id IN (SELECT id FROM venues WHERE owner_id = auth.uid()));

-- Add comments for documentation
COMMENT ON TABLE tables IS 'Main table management with capacity and status tracking';
COMMENT ON TABLE table_sessions IS 'Track dining sessions for billing and analytics';
COMMENT ON TABLE table_orders IS 'Link tables to orders for tracking';
COMMENT ON TABLE table_notifications IS 'Handle table-specific notifications and requests';

COMMENT ON COLUMN tables.status IS 'Current table status: free, occupied, waiting_order, producing, delivered, bill_requested, paid';
COMMENT ON COLUMN tables.current_guests IS 'Number of currently seated guests (cannot exceed capacity)';
COMMENT ON COLUMN table_sessions.total_spent IS 'Total amount spent during this session';
COMMENT ON COLUMN table_notifications.type IS 'Type of notification: waiter_call, bill_request, special_request';